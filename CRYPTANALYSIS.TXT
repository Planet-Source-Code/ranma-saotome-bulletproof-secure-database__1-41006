Initial Cryptanalysis of DS2
By: David Midkiff, Mark McConnel, Caleb Walters
-----------------------------------------------

DS2 is a stream cipher somewhat similar to RC4 but much different in design and in our opinion much more secure. From analysis the key is variable length and presumably undeterminable. A very large key can have an extraordinary impact on a large block of data. The KeyInit sub that David implemented allows for a 65025 byte key (520200-bits) to affect sbox_a directly. Likewise the actual encryption/decryption uses key values/positions to determine sbox positions. While 520200-bits can directly effect the sbox a much larger key can still have an effect on larger chunks of data. The larger the data chunk is the larger the key size can be. If the end of a 500 byte block of data is reached and the key is 1000 bytes then only 500 bytes (4000-bits) of they key (.5) will have an impact on the data. While this initially appears to be a form of padding it is far from it. SBox positions are called using key ASCII values from an iterated position of the key. If the algorithm runs into the end of the key and still has more data to encrypt then it starts back at the beginning. This is similar to the concept of padding except that in this case there is no real padding being performed, rather actual encryption using the substitution boxes.

The salt functions in DS2 appends 6 random bytes of data to the stream providing 274 trillion possible ciphertext results from a single input. This makes DS2 extremely hard to cryptanalyze. Likewise the algorithm is iterated 4 times (rounds) providing decent resistance against differential cryptanalysis. We recommend possibly increasing this to 8 to provide resistance for years to come.

The only noted weakness is found in the key expansion routine. DS2 requires a 16-bit key or greater. If the provided key is less than 16-bits then simple key expansion is performed to force it to 16-bits. This is done by appending ASCII character 1 into the key array until 16-bits is achieved. This opens up a class of around 65025 16-bit keys which produce the same results. Since 16-bit keys are extremely insecure against key exhaustion the key expansion method really does not open up any serious security holes. Someone implementing the algorithm could simply remove the key-expansion code and force the user to provide a 16-bit or greater key.

The pseudo-random number generator employed in DS2 is an excellent design which gathers 10 different seeds from seemingly random sources to produce a genuinly random seed for the congruential generator in Visual Basic. This provides added security to the salt function in DS2 making DS2 much harder to cryptanalyze.

An initial differential attack by Caleb produced no significant results against DS2. An attempted attack on the salt function by David also produced no significant results. From our analysis DS2 appears to be in good shape and worthy of cryptographic solutions. We hope that submitting this to the much larger cryptography community after it is complete may produce more analytic results. In such a case we will update the cipher to resist new forms of attack.